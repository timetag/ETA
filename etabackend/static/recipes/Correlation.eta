{"vi_templatejg59migx":"{\"nodes\":[{\"x\":101,\"y\":101,\"fixed\":true,\"text\":\"a\",\"px\":101,\"py\":101,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(4,`bw_delay`)# here, ch1 is duplicated to ch3 with a delay of 0ps\"}","vi_templatejfc9koma":"{\"nodes\":[{\"x\":82,\"y\":88,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":88,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"0\"}],\"usercode\":\"a:\\n    emit(3,`fw_delay`)# here, ch0 is duplicated to ch2 with a delay of 0ps\"}","vi_templatejg52ksbp":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":95,\"y\":102,\"fixed\":true,\"text\":\"stop\",\"px\":95,\"py\":102,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"4\"},{\"source\":1,\"target\":0,\"text\":\"3\"},{\"source\":0,\"target\":0,\"text\":\"3\"},{\"source\":1,\"target\":1,\"text\":\"4\"}],\"usercode\":\"HISTOGRAM(h4,(`bins`,`binsize`,\\\"time-1\\\"))\\nHISTOGRAM(h4_zero,(1,1))\\nCLOCK(c4,100,1)\\nstart:\\n    c4.start()\\nstop:\\n    c4.stop()\\n    h4.record_all(c4)\\n    h4_zero.record_all(c4)\"}","vi_templatejfb2qshf":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":102,\"y\":102,\"fixed\":true,\"text\":\"stop\",\"px\":102,\"py\":102,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"3\"},{\"source\":1,\"target\":0,\"text\":\"4\"},{\"source\":0,\"target\":0,\"text\":\"4\"},{\"source\":1,\"target\":1,\"text\":\"3\"}],\"usercode\":\"HISTOGRAM(h3,(`bins`,`binsize`))\\nCLOCK(c3,100,1)\\nstart:\\n    c3.start()\\nstop:\\n    c3.stop()\\n    h3.record_all(c3)\"}","dpp_template_code":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\n\r\nimport dash\r\nimport dash_core_components as dcc\r\nimport dash_html_components as html\r\nimport plotly.graph_objs as go\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\ncut=eta.clips(Path(file))\r\nresult= eta.run({\"timetagger1\":cut}, group=HH400_mode)\r\nhist1=result[\"h3\"]\r\nhist2=result[\"h4\"]\r\nhist0=result[\"h4_zero\"]\r\nhist1[0]+= hist0[0]\r\n\r\nfullhist=np.concatenate((hist2[::-1],hist1))\r\n#------PLOTTING-----\r\napp = dash.Dash()\r\napp.layout = html.Div(children=[\r\n    dcc.Graph(\r\n        id='example-ss',\r\n        figure={\r\n            'data': [\r\n                {\r\n                    'x': np.arange(-hist2.size,hist1.size)*int(float(binsize)), \r\n                    'y': fullhist,\r\n                    'type': 'bar',\r\n                    'name': 'bwd',\r\n                    'marker': {\r\n                        'color': '#0571b0'\r\n                    }\r\n                    \r\n                },\r\n            ],\r\n            'layout': {\r\n                'autosize':True,\r\n                'title': 'Start Stop Measurement',\r\n                'barmode': 'stack',\r\n                'xaxis' : {'title' : 'Time Delay (ps)'},\r\n                'yaxis' : {'title' : 'Coincidence Events'}\r\n            }\r\n        },\r\n        style={ \"height\" : \"100vh\"}\r\n    )\r\n], style={ \"height\" : \"100vh\"})\r\neta.display(app)","eta_index_table":"[{\"id\":\"var_templatejgmgopco\",\"name\":\"file\",\"group\":\"HHT2,HHT3, quTAG, general\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.timeres\"},{\"id\":\"var_templatejkim8l39\",\"name\":\"binsize\",\"group\":\"HHT2,HHT3, quTAG, general\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkim8rzm\",\"name\":\"expname\",\"group\":\"HHT2,HHT3, quTAG\",\"info\":\"\",\"config\":\"Correlation\"},{\"id\":\"var_templatejkim8w21\",\"name\":\"bins\",\"group\":\"HHT2,HHT3,quTAG\",\"info\":\"\",\"config\":\"10000\"},{\"id\":\"var_templatejkim95ub\",\"name\":\"plotsize_x\",\"group\":\"general\",\"info\":\"\",\"config\":\"3200\"},{\"id\":\"var_templatejrvu8s5g\",\"name\":\"analyze_timewindow\",\"group\":\"general\",\"info\":\"\",\"config\":\"True\"},{\"id\":\"var_templatek71lu4ak\",\"name\":\"records_per_cut\",\"group\":\"HHT3,HHT2\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatek7uj6ou8\",\"name\":\"HH400_mode\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"HHT3\"},{\"id\":\"var_templatek8g3kag4\",\"name\":\"delay\",\"group\":\"HHT2,HHT3, quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8g498fo\",\"name\":\"bw_delay\",\"group\":\"HHT2,HHT3, quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"var_templatek8g49hcs\",\"name\":\"fw_delay\",\"group\":\"HHT2,HHT3, quTAG\",\"info\":\"\",\"config\":\"0\"},{\"id\":\"dpp_templatek88yfdpn\",\"name\":\"display (HH400)\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_template_code\",\"name\":\"plotly (HH400)\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0e4feyu\",\"name\":\"plotly (quTAG)\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0e4ffk5\",\"name\":\"create txt (HH400)\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek0e4ffxo\",\"name\":\"create txt (quTAG)\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejgs3h609\",\"name\":\"txt 2 graph (zoom-in)\",\"group\":\"general\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejgs1c21d\",\"name\":\"txt 2 g2 analysis and graph\",\"group\":\"general\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek71lpql0\",\"name\":\"realtime_tkinter\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek7r3sgz1\",\"name\":\"realtime_bokeh\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek71lreos\",\"name\":\"qutag_start_recording\",\"group\":\"quTAG\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek71ls0bm\",\"name\":\"swabianinstrument_start_recording\",\"group\":\"SI\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek71lsiq3\",\"name\":\"hydraharp_start_recording\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatek71lsycj\",\"name\":\"hydraharp400_HeaderGenerator_download\",\"group\":\"HHT2,HHT3\",\"info\":\"\",\"config\":\"\"},{\"id\":\"vi_templatek6z7rk2w\",\"name\":\"HH400\",\"group\":\"HHT2,HHT3\",\"info\":\"游닆[0, 1, 2] \",\"config\":\"\"},{\"id\":\"vi_templatek6z7s4mo\",\"name\":\"quTAG\",\"group\":\"quTAG\",\"info\":\"游닆[0, 1, 2, 3, 4, 5] \",\"config\":\"\"},{\"id\":\"vi_templatek0e44hsk\",\"name\":\"DL1-3 (HHT2)\",\"group\":\"HHT2\",\"info\":\"游닌[1] 游닋[3] \",\"config\":\"\"},{\"id\":\"vi_templatek0e44v54\",\"name\":\"DL2-4 (HHT2)\",\"group\":\"HHT2\",\"info\":\"游닌[2] 游닋[4] \",\"config\":\"\"},{\"id\":\"vi_templatejfc9koma\",\"name\":\"DL0-3 (HHT3)\",\"group\":\"HHT3\",\"info\":\"游닌[0] 游닋[3] \",\"config\":\"\"},{\"id\":\"vi_templatejg59migx\",\"name\":\"DL1-4 (HHT3)\",\"group\":\"HHT3\",\"info\":\"游닌[1] 游닋[4] \",\"config\":\"\"},{\"id\":\"vi_templatejg52ksbp\",\"name\":\"Correlationbwd (HH400)\",\"group\":\"HHT2,HHT3\",\"info\":\"游닌[4, 3] \",\"config\":\"\"},{\"id\":\"vi_templatejfb2qshf\",\"name\":\"Correlationfwd  (HH400)\",\"group\":\"HHT2,HHT3\",\"info\":\"游닌[3, 4] \",\"config\":\"\"},{\"id\":\"vi_templatek0e3lgeo\",\"name\":\"DL1-6  (quTAG)\",\"group\":\"quTAG\",\"info\":\"游닌[1] 游닋[6] \",\"config\":\"\"},{\"id\":\"vi_templatek0e3lz43\",\"name\":\"DL2-7 (quTAG)\",\"group\":\"quTAG\",\"info\":\"游닌[2] 游닋[7] \",\"config\":\"\"},{\"id\":\"vi_templatek0e3qybt\",\"name\":\"Correlationbwd (quTAG)\",\"group\":\"quTAG\",\"info\":\"游닌[7, 6] \",\"config\":\"\"},{\"id\":\"vi_templatek0e3sowi\",\"name\":\"Correlationfwd (quTAG)\",\"group\":\"quTAG\",\"info\":\"游닌[6, 7] \",\"config\":\"\"}]","var_templatejgmgopco":null,"dpp_templatejgs1c21d":"#------IMPORTS-----\r\nfrom pathlib import Path\r\n\r\nimport numpy as np\r\nimport pandas as pd\r\n\r\nimport matplotlib.pyplot as plt\r\n\r\ndef get_files(extensions):\r\n    global path, datafolder\r\n    path=path.joinpath(datafolder)\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n\r\nanalyze_timewindow = bool(analyze_timewindow)\r\n\r\n#------ETA PROCESSING-----\r\ndatafolder='analyzed data'\r\ngraphsfolder='graphs'\r\npath = Path(file)\r\n\r\nif path.is_dir():\r\n    selector = get_files(('*.txt',))\r\nelse:\r\n    if path.suffix == '.txt':\r\n        selector = [path]\r\n    else:\r\n        selector = [path.parent.joinpath(datafolder, path.stem + '_correlation' + '.txt')]\r\n\r\nfor f in selector:\r\n        list_of_title=f.stem.split('_')\r\n\r\n        data=pd.read_table(f, header=None, names=['ps', 'cnts'], sep=' ')\r\n        data.set_index('ps', inplace=True)\r\n        data = data['cnts']\r\n        \r\n        numberofsidepeaks = 8 # must be even\r\n        bin=16\r\n        shift = 0\r\n        widthofdata = 120000 #how the data is going to be cut. Allow enough ps to accomodate the numberofsidepeaks\r\n        leftend = int(-widthofdata/2+shift)\r\n        rightend = int(widthofdata/2+shift)\r\n        lessthanrep = 12300 #less than the laser repetition rate in ps\r\n        \r\n        reprate = int(((data.loc[rightend-lessthanrep:rightend].idxmax()-data.loc[leftend:leftend+lessthanrep].idxmax())/int(numberofsidepeaks)))\r\n        \r\n        g2vsdT = pd.DataFrame()\r\n        for window in range(bin, lessthanrep, bin):\r\n            peaks = np.array([])\r\n            \r\n            for x in range(int(data.loc[leftend:leftend+reprate].idxmax()), rightend, reprate):\r\n                temp0=data.loc[x-window/2:x+window/2].sum()\r\n                peaks=np.append([peaks], [temp0])\r\n        \r\n            center = peaks[int(numberofsidepeaks/2)]\r\n            average = np.mean([peaks[:int(numberofsidepeaks/2)], peaks[1+int(numberofsidepeaks/2):]])\r\n            average_err = (np.sqrt(np.sum([peaks[:int(numberofsidepeaks/2)], peaks[1+int(numberofsidepeaks/2):]]))/int(numberofsidepeaks))\r\n            g2 = center/average\r\n            g2_err = np.sqrt(center/(average**2)+(average_err**2)*(peaks[int(numberofsidepeaks/2)]**2)/average**4)\r\n            \r\n            if window == 1600:\r\n                print('Time window: '+str(window)+' ps'+'\\n'+'average counts per peak: '+str(average) + ' pm ' + str(average_err) + '\\n' + 'g2: '+ str(g2)+ ' pm ' + str(g2_err)+'\\n'+'center peak delay: ' + str(reprate*(numberofsidepeaks/2)+data.loc[leftend:leftend+lessthanrep].idxmax())+' ps' +'\\n'+'pulse delay: '+str(reprate)+' ps')\r\n                center_peak_delay = reprate*(numberofsidepeaks/2)+data.loc[leftend:leftend+lessthanrep].idxmax()\r\n                good_average = average\r\n                good_average_err = average_err\r\n                good_g2 = g2\r\n                good_g2_err = g2_err\r\n            temp1 = pd.DataFrame([[window, g2, g2_err]], columns=['Time Window', 'g(2)', 'delta g(2)'])\r\n            g2vsdT = pd.concat([g2vsdT, temp1], ignore_index=True)\r\n        \r\n        \r\n        g2vsdT.set_index('Time Window', inplace=True)\r\n        g2vsdT = pd.concat([g2vsdT, g2vsdT['g(2)']+g2vsdT['delta g(2)'], g2vsdT['g(2)']-g2vsdT['delta g(2)']], axis=1)\r\n        g2vsdT.rename(columns={0:'err+', 1:'err-'}, inplace=True)\r\n        \r\n        title='average counts per peak: '+str(int(good_average)) + r' $\\pm$ ' + str(int(good_average_err)) + '\\n' + 'g2: '+  \"{0:.6f}\".format(good_g2) + r' $\\pm$ ' + \"{0:.6f}\".format(good_g2_err)\r\n        data = data.loc[leftend:rightend]\r\n        p1 = plt.bar(data.index,data, width=bin, color='salmon', log=True)\r\n\r\n        plt.ylabel('correlation events')\r\n        plt.xlabel('time (ps)')\r\n        plt.title(title)\r\n        f.parent.parent.joinpath(graphsfolder).mkdir(parents=True, exist_ok=True)\r\n        plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_analyzed' + '.eps'), format='eps', dpi=1200)\r\n        plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_analyzed' + '.png'), format='png', dpi=1200)\r\n        plt.clf()\r\n        \r\n        if analyze_timewindow == True:\r\n            plt.plot(g2vsdT.index, g2vsdT['g(2)'], 'b')\r\n            plt.fill_between(g2vsdT.index, g2vsdT['err+'], g2vsdT['err-'], color='b', alpha=0.2)\r\n            plt.ylabel('g2(0)')\r\n            plt.xlabel('analysis window (ps)')\r\n            plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_windows' + '.eps'), format='eps', dpi=1200)\r\n            plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_windows' + '.png'), format='png', dpi=1200)\r\n            plt.clf()","dpp_templatejgs3h609":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\n\r\ndef get_files(extensions):\r\n    global path, datafolder\r\n    path=path.joinpath(datafolder)\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n\r\n#------ETA PROCESSING-----\r\ngraphsfolder='graphs'\r\ndatafolder='analyzed data'\r\npath = Path(file)\r\n\r\nif path.is_dir():\r\n    selector = get_files(('*.txt',))\r\nelse:\r\n    if path.suffix == '.txt':\r\n        selector = [path]\r\n    else:\r\n        selector = [path.parent.joinpath(datafolder, path.stem + '_correlation' + '.txt')]\r\n\r\nplotsize_x=int(plotsize_x)\r\nbinsize=int(float(binsize))\r\n\r\nfor f in selector:\r\n        print(f.stem)\r\n        data=np.loadtxt(f)\r\n        read_bins=len(np.transpose(data)[0])\r\n        p1 = plt.bar(data[int((read_bins-plotsize_x/binsize)/2):int((read_bins+plotsize_x/binsize)/2),0], data[int((read_bins-plotsize_x/binsize)/2):int((read_bins+plotsize_x/binsize)/2),1],width=binsize, color='#0088ff')\r\n        plt.ylabel('events')\r\n        plt.xlabel('time (ps)')\r\n        f.parent.parent.joinpath(graphsfolder).mkdir(parents=True, exist_ok=True)\r\n        plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_inset' + '.eps'), format='eps', dpi=1200)\r\n        plt.savefig(f.parent.parent.joinpath(graphsfolder, f.stem + '_inset' + '.png'), format='png', dpi=1200)\r\n        plt.clf()\r\n        eta.send(f.name + ' has been successfully plotted')","var_templatejkim8l39":null,"var_templatejkim8rzm":null,"var_templatejkim8w21":null,"var_templatejkim95ub":null,"var_templatejrvu8s5g":null,"vi_templatek0e3lgeo":"{\"nodes\":[{\"x\":121,\"y\":114,\"fixed\":true,\"text\":\"a\",\"initial\":true,\"px\":121,\"py\":114}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(6,`fw_delay`)\"}","vi_templatek0e3lz43":"{\"nodes\":[{\"x\":89,\"y\":107,\"fixed\":true,\"initial\":true,\"text\":\"a\"}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(7,`bw_delay`)\"}","vi_templatek0e3qybt":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":75,\"y\":86,\"fixed\":true,\"text\":\"stop\",\"px\":75,\"py\":86,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"7\"},{\"source\":1,\"target\":0,\"text\":\"6\"},{\"source\":0,\"target\":0,\"text\":\"6\"},{\"source\":1,\"target\":1,\"text\":\"7\"}],\"usercode\":\"HISTOGRAM(h4,(`bins`,`binsize`))\\nHISTOGRAM(h4_zero,(1,1))\\nCLOCK(c4,100,1)\\nstart:\\n    c4.start()\\nstop:\\n    c4.stop()\\n    h4.record_all(c4)\\n    h4_zero.record_all(c4)\"}","vi_templatek0e3sowi":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":76,\"y\":88,\"fixed\":true,\"text\":\"stop\",\"px\":76,\"py\":88,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"6\"},{\"source\":1,\"target\":0,\"text\":\"7\"},{\"source\":0,\"target\":0,\"text\":\"7\"},{\"source\":1,\"target\":1,\"text\":\"6\"}],\"usercode\":\"HISTOGRAM(h3,(`bins`,`binsize`))\\nCLOCK(c3,100,1)\\nstart:\\n    c3.start()\\nstop:\\n    c3.stop()\\n    h3.record_all(c3)\"}","vi_templatek0e44hsk":"{\"nodes\":[{\"x\":82,\"y\":88,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":88,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(3,`fw_delay`)# here, ch0 is duplicated to ch2 with a delay of 0ps\"}","vi_templatek0e44v54":"{\"nodes\":[{\"x\":101,\"y\":101,\"fixed\":true,\"text\":\"a\",\"px\":101,\"py\":101,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"2\"}],\"usercode\":\"a:\\n    emit(4,`bw_delay`)# here, ch1 is duplicated to ch3 with a delay of 0ps\"}","dpp_templatek0e4feyu":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\n\r\nimport dash\r\nimport dash_core_components as dcc\r\nimport dash_html_components as html\r\nimport plotly.graph_objs as go\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\ncut=eta.clips(Path(file))\r\nresult= eta.run({\"timetagger1\":cut}, group='quTAG')\r\nhist1=result[\"h3\"]\r\nhist2=result[\"h4\"]\r\nhist0=result[\"h4_zero\"]\r\nhist1[0]+= hist0[0]\r\n\r\nfullhist=np.concatenate((hist2[::-1],hist1))\r\n#------PLOTTING-----\r\napp = dash.Dash()\r\napp.layout = html.Div(children=[\r\n    dcc.Graph(\r\n        id='example-ss',\r\n        figure={\r\n            'data': [\r\n                {\r\n                    'x': np.arange(-hist2.size,hist1.size)*int(float(binsize)), \r\n                    'y': fullhist,\r\n                    'type': 'bar',\r\n                    'name': 'bwd',\r\n                    'marker': {\r\n                        'color': '#0571b0'\r\n                    }\r\n                    \r\n                },\r\n            ],\r\n            'layout': {\r\n                'autosize':True,\r\n                'title': 'Start Stop Measurement',\r\n                'barmode': 'stack',\r\n                'xaxis' : {'title' : 'Time Delay (ps)'},\r\n                'yaxis' : {'title' : 'Coincidence Events'}\r\n            }\r\n        },\r\n        style={ \"height\" : \"100vh\"}\r\n    )\r\n], style={ \"height\" : \"100vh\"})\r\neta.display(app)","dpp_templatek0e4ffk5":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\nimport etabackend.tk.utils as etautils\r\n\r\ndef get_files(extensions):\r\n    global path\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n    \r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\nbinsize=int(float(binsize))\r\npath = Path(file)\r\ndatafolder='analyzed data'\r\n\r\nselector = (f for f in get_files(('*.ptu','*.timeres'))) if path.is_dir() else [path]\r\n\r\nfor f in selector:\r\n        cutfile = eta.clips(f)\r\n        result=eta.run({\"timetagger1\":cutfile}, group=HH400_mode)\r\n        hist1=result[\"h3\"]\r\n        hist2=result[\"h4\"] \r\n        hist0=result[\"h4_zero\"]\r\n        hist1[0]+= hist0[0]\r\n        fullhist=np.concatenate((hist2[::-1],hist1))\r\n        f.parent.joinpath(datafolder).mkdir(parents=True, exist_ok=True)\r\n        np.savetxt(f.parent.joinpath(datafolder, f.stem + '_correlation' +  '.txt'), np.transpose([np.arange(-hist2.size,hist1.size)*binsize,fullhist]), delimiter='\\t', header=etautils.info(globals_dict=globals(), recipe_type='correlation'))\r\n        eta.send(str(f.name) + ' has been successfully processed')\r\neta.send('FINISHED')\r\n\r\n","dpp_templatek0e4ffxo":"#------IMPORTS-----\r\nfrom pathlib import Path\r\nimport numpy as np\r\nimport etabackend.tk.utils as etautils\r\n\r\ndef get_files(extensions):\r\n    global path\r\n    all_files = []\r\n    for ext in extensions:\r\n        all_files.extend(path.glob(ext))\r\n    return all_files\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\n#------ETA PROCESSING-----\r\nbinsize=int(float(binsize))\r\npath = Path(file)\r\ndatafolder='analyzed data'\r\n\r\nselector = (f for f in get_files(('*.ptu','*.timeres'))) if path.is_dir() else [path]\r\n\r\nfor f in selector:\r\n        cutfile = eta.clips(f)\r\n        result=eta.run({\"timetagger1\":cutfile}, group='quTAG')\r\n        hist1=result[\"h3\"]\r\n        hist2=result[\"h4\"]\r\n        hist0=result[\"h4_zero\"]\r\n        hist1[0]+= hist0[0]\r\n        fullhist=np.concatenate((hist2[::-1],hist1))\r\n        f.parent.joinpath(datafolder).mkdir(parents=True, exist_ok=True)\r\n        np.savetxt(f.parent.joinpath(datafolder, f.stem + '_correlation' +  '.txt'), np.transpose([np.arange(-hist2.size,hist1.size)*binsize,fullhist]), delimiter='\\t', header=etautils.info(globals_dict=globals(), recipe_type='correlation'))\r\n        eta.send(str(f.name) + ' has been successfully processed')\r\neta.send('FINISHED')\r\n\r\n","vi_templatek6z7rk2w":"{\"nodes\":[{\"x\":129,\"y\":62,\"fixed\":true,\"initial\":true}],\"edges\":[],\"usercode\":\"\\n########## click Help on the menu to get started! ##########\\nRFILE(timetagger1,[0,1,2])\"}","vi_templatek6z7s4mo":"{\"nodes\":[{\"x\":192,\"y\":157,\"fixed\":true,\"initial\":true}],\"edges\":[],\"usercode\":\"\\n########## click Help on the menu to get started! ##########\\nRFILE(timetagger1,[0,1,2,3,4,5])\"}","dpp_templatek71lpql0":"from enum import Enum\r\nimport logging\r\nimport pathlib\r\nimport etabackend.tk.utils as etautils\r\n\r\nimport numpy as np\r\nimport matplotlib\r\nmatplotlib.use('TkAgg')\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.animation as animation\r\nimport matplotlib.widgets\r\nfrom matplotlib.widgets import Button\r\n\r\nlogger = logging.getLogger('etabackend.frontend')\r\neta.send(\"\", \"running\")  # FIXME:USE NEW API\r\nlogger.info(\"ETA realtime is started.\")\r\nrecords_per_cut = int(float(records_per_cut)\r\n                      ) if records_per_cut != \"\" else None\r\n\r\nSIMULATE_GROWTH = True\r\nDATAFOLDER = 'analyzed data'\r\nLABEL = 'histogram'\r\n\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\nbin_factor = int(float(binsize))\r\nfile = pathlib.Path(file)\r\n\r\nfig, ax = plt.subplots()\r\nax.set_ylabel('Histogram events')\r\nax.set_xlabel('Time delay (ps)')\r\nax.set_title(expname)\r\n\r\n#------ADJUST DELAY-----\r\ndelay = int(float(delay))\r\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\r\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\r\neta.load_recipe()\r\n\r\nclass DataPlot(object):\r\n    def __init__(self, fig, ax, file, bin_factor,\r\n                 records_per_cut=None, interval=100,\r\n                 numpy=None, widgets=None):\r\n        \"\"\" Calculates the next cut and writes it to the plot\r\n            ax: Axis to draw on\r\n            file: str or Path of file currently investigated\r\n            bin_factor: The multiplication factor for each bin.\r\n            interval: The interval of the simulation\r\n            timeout: How long to wait for enough data until frame is skipped (milliseconds)\r\n        \"\"\"\r\n        global SIMULATE_GROWTH\r\n\r\n        self.file = file\r\n        self.bin_factor = bin_factor\r\n        self.records_per_cut = records_per_cut\r\n\r\n        self.fig = fig\r\n        self.ax = ax\r\n        self.fig.subplots_adjust(bottom=0.22)\r\n\r\n        self.line, = self.ax.plot([], [], 'r-')\r\n        self.interval = interval\r\n        self.numpy = numpy\r\n        self.widgets = widgets\r\n\r\n        self.set_accumulation_mode()\r\n\r\n        # Setup Widgets\r\n        axsavedat = self.fig.add_axes([0.59, 0.05, 0.1, 0.075])\r\n        axmode = self.fig.add_axes([0.7, 0.05, 0.1, 0.075])\r\n        axlinlog = self.fig.add_axes([0.81, 0.05, 0.1, 0.075])\r\n        self.bsavedat = widgets.Button(axsavedat, 'Save')\r\n        self.blinlog = widgets.Button(axlinlog, 'Lin/Log')\r\n        self.bmode = widgets.Button(axmode, 'Mode')\r\n        self.bsavedat.on_clicked(self.save_dat)\r\n        self.blinlog.on_clicked(self.toggle_scale)\r\n        self.bmode.on_clicked(self.toggle_mode)\r\n\r\n        # First cut to detect file properties and rate estimation\r\n        self.cut = eta.clip_file(\r\n            self.file, modify_clip=None, read_events=1, format=-1, wait_timeout=0)\r\n\r\n        if self.records_per_cut is None:\r\n            self.estimate_growth()\r\n\r\n        self.context = None\r\n\r\n        if SIMULATE_GROWTH is False:\r\n            file_size = self.file.stat().st_size\r\n            file_size = file_size - self.cut.fseekpoint\r\n            existing_records = file_size//self.cut.BytesofRecords\r\n        else:\r\n            existing_records = self.records_per_cut\r\n\r\n        self.cut = eta.clip_file(self.file, modify_clip=None,\r\n                                      read_events=existing_records, wait_timeout=0.5)  # Start always from begining of file\r\n\r\n        result, self.context = eta.run({\"timetagger1\":self.cut}, resume_task=None, group=HH400_mode,\r\n                                       return_task=True,\r\n                                       return_results=True, max_autofeed=1)\r\n        self.hist1 = result['h3']\r\n        self.hist2 = result['h4']\r\n        self.hist0 = result[\"h4_zero\"]\r\n        self.hist1[0] += self.hist0[0]\r\n        self.ydata = self.numpy.concatenate((self.hist2[::-1],self.hist1))\r\n        self.max_value = self.numpy.amax(self.ydata)\r\n        self.y_max = self.max_value*1.5\r\n\r\n        self.xdata = self.numpy.arange(-self.hist2.size,\r\n                                       self.hist1.size)*self.bin_factor\r\n\r\n    def estimate_growth(self):\r\n        \"\"\" Estimates the grow rate per second, will sleep for 1000ms.\r\n        The event loop continues running.\r\n        \"\"\"\r\n        logger.info('Estimating File growth.')\r\n        file_size_old = self.file.stat().st_size\r\n        plt.pause(1)\r\n        file_size_new = self.file.stat().st_size\r\n        logger.info('Done.')\r\n\r\n        self.growth_rate = (file_size_new - file_size_old) / \\\r\n            self.cut.BytesofRecords  # Bytes per record\r\n        self.records_per_cut = int(self.growth_rate * self.interval)\r\n\r\n    def init(self):\r\n        \"\"\" Initializes the figure\r\n        \"\"\"\r\n        self.ax.set_xlim(-self.hist2.size*self.bin_factor,\r\n                         self.hist1.size*self.bin_factor)\r\n        self.line.set_xdata(self.xdata)\r\n\r\n        self.y_max = self.numpy.amax(self.ydata)*1.5\r\n        self.ax.set_ylim(0.01, self.y_max)\r\n        self.line.set_ydata(self.ydata)\r\n\r\n        return self.line,\r\n\r\n    def __call__(self, i):\r\n        # This way the plot can continuously run and we just keep\r\n        # watching new realizations of the process\r\n        if i == 0:\r\n            return self.init()\r\n\r\n        check_ret = eta.clip_file(self.file, modify_clip=self.cut,\r\n                                       read_events=self.records_per_cut, wait_timeout=0.5)\r\n        if not check_ret:\r\n            # No new data available, we do not modify the plot\r\n            return self.line,\r\n        else:\r\n            self.cut = check_ret  # save the ret to cut\r\n            context = self.context if self.mode == 'accumulation' else None\r\n            result, self.context = eta.run({\"timetagger1\":self.cut}, resume_task=self.context, group=HH400_mode,\r\n                                           return_task=True,\r\n                                           return_results=True, max_autofeed=1)\r\n\r\n            self.hist1 = result['h3']\r\n            self.hist2 = result['h4']\r\n            self.hist0 = result[\"h4_zero\"]\r\n            self.hist1[0] += self.hist0[0]\r\n            self.ydata = self.numpy.concatenate((self.hist2[::-1],self.hist1))\r\n\r\n        max_value = self.numpy.amax(self.ydata)\r\n        if max_value >= self.y_max*0.9 or max_value < self.max_value*0.9:\r\n            self.y_max = max_value*1.5\r\n            self.max_value = max_value\r\n            self.ax.set_ylim(0.01, self.y_max)\r\n            self.fig.canvas.draw_idle()\r\n\r\n        self.line.set_ydata(self.ydata)\r\n        return self.line,\r\n\r\n    def toggle_scale(self, event):\r\n        if self.ax.get_yscale() == 'log':\r\n            self.set_linear()\r\n        elif self.ax.get_yscale() == 'linear':\r\n            self.set_log()\r\n        self.fig.canvas.draw_idle()\r\n\r\n    def set_log(self):\r\n        print(self.numpy.min(self.ydata))\r\n\r\n        self.ax.set_yscale('log', nonposy='clip')\r\n\r\n    def set_linear(self):\r\n        self.ax.set_yscale('linear')\r\n\r\n    def set_accumulation_mode(self):\r\n        self.mode = 'accumulation'\r\n\r\n    def set_alignment_mode(self):\r\n        self.mode = 'align'\r\n\r\n    def toggle_mode(self, event):\r\n        if self.mode == 'align':\r\n            self.set_accumulation_mode()\r\n        elif self.mode == 'accumulation':\r\n            self.set_alignment_mode()\r\n\r\n    def save_dat(self, event):\r\n        global DATAFOLDER, LABEL\r\n        self.file.parent.joinpath(DATAFOLDER).mkdir(\r\n            parents=True, exist_ok=True)  # Create analyzed folder\r\n\r\n        file_index = 0\r\n        # create unique index for file\r\n        while self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\").exists():\r\n            file_index += 1\r\n\r\n        self.numpy.savetxt(self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\"),\r\n                           self.numpy.transpose([self.xdata, self.ydata]))\r\n\r\n\r\ndp = DataPlot(fig, ax, file, bin_factor, records_per_cut, interval=100,\r\n              numpy=np, widgets=matplotlib.widgets)\r\n\r\nani = animation.FuncAnimation(fig, dp, init_func=dp.init, interval=100, repeat=False,\r\n                              cache_frame_data=False, blit=True)\r\nlogger.info('No further logoutput for the realtime recipe.')\r\nlogger.setLevel(logging.WARNING)\r\n\r\nplt.show()\r\nlogger.info(\"ETA realtime is stopped.\")\r\neta.send(\"\", \"stopped\")  # FIXME:USE NEW API\r\n","dpp_templatek71lreos":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\nif not os.path.isfile(\"tdcbase.dll\"):\r\n    eta.send(\"Installing ETA DLC... \", \"running\")\r\n    \r\n    eta.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/qutaglib/quTAGlibV1.4.1.zip\",\"./\",\"quTAGlibV141.zip\")\r\n    eta.send(\"ETA DLC installed. \", \"stopped\")\r\ntry:\r\n    qutag = cdll.LoadLibrary(\"tdcbase.dll\")\r\nexcept Exception:\r\n    eta.send(\"You need to copy tdcbase.dll along with other dlls to the same folder of ETA-Backend.exe\",\"err\")\r\n    #You can find those DLLs from the 64bit library at\r\n    #https://www.qutools.com/\r\n    #You might also need a newer version of quTAG driver that allows configuration of the filters\r\nqutag.TDC_getVersion.restype=c_double\r\nprint(qutag.TDC_getVersion())\r\nrc = qutag.TDC_init( -1 )\r\nprint( \"TDC_init\", rc )\r\nrc = qutag.TDC_enableChannels( 0xff ) # Use all channels \r\nprint( \"TDC_enableChannels\", rc )\r\n\r\n\r\nrc = qutag.TDC_configureFilter(5,3,0b00110) # (channel to filter, enumerator for filtertype (3=sync),0bchannelmask)\r\nprint( \"TDC_configureFilter\", rc )\r\n\r\nfilename= str(file).encode(\"utf-8\")\r\neta.send(\"Timetags will be written to {}\".format(filename))\r\neta.send(\"ETA starting reading the timetags from device...\", \"running\")\r\nrc = qutag.TDC_writeTimestamps(create_string_buffer(filename),1)#start acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\ntime.sleep(10)\r\nrc = qutag.TDC_writeTimestamps(POINTER(c_int)(),1)#stop acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")","dpp_templatek71ls0bm":"import sys\r\ntry:\r\n    import TimeTagger\r\nexcept:\r\n    print(\"Time Tagger lib is not in the search path.\")\r\n    pyversion = sys.version_info\r\n    from winreg import ConnectRegistry, OpenKey, HKEY_LOCAL_MACHINE, QueryValueEx\r\n    registry_path = \"SOFTWARE\\\\Python\\\\PythonCore\\\\\" + \\\r\n        str(pyversion.major) + \".\" + str(pyversion.minor) + \"\\\\PythonPath\\\\Time Tagger\"\r\n    reg = ConnectRegistry(None, HKEY_LOCAL_MACHINE)\r\n    key = OpenKey(reg, registry_path)\r\n    module_path = QueryValueEx(key, '')[0]\r\n    print(\"adding \" + module_path)\r\n    sys.path.append(module_path)\r\nimport TimeTagger\r\n\r\nfrom time import sleep\r\n\r\ntagger = TimeTagger.createTimeTagger()\r\ntagger.reset();\r\n#disabling the test signals\r\ntagger.setTestSignal(0, False)\r\ntagger.setTestSignal(1, False)\r\ntagger.setTestSignal(5, False)\r\n#setTriggerLevel to chn0 ,chn1, chn5\r\ntagger.setTriggerLevel(0, 0.1)\r\ntagger.setTriggerLevel(1, 0.1)\r\ntagger.setTriggerLevel(5, 0.1)\r\ntagger.sync()\r\ncountrate =  TimeTagger.Countrate( tagger, channels=[0,1,5] )\r\nsleep(1)\r\neta.send('countrate:')\r\neta.send(countrate.getData())\r\n\r\neta.send('starting time-tagging',\"running\")\r\ndump =  TimeTagger.Dump(tagger,'swebian.bin',100000,[0,1,5])\r\nsleep(10)\r\neta.send('stopping time-tagging', \"stopped\")","dpp_templatek71lsiq3":"#TODO(20181124) This script is not yet tested on a real device.\r\n\r\n# Demo for access to HydraHarp 400 Hardware via HHLIB.DLL v 3.0.\r\n# The program performs a measurement based on hard coded settings.\r\n# The resulting data is stored in a binary output file.\r\n#\r\n# Keno Goertz, PicoQuant GmbH, February 2018\r\n\"\"\"\r\nDisclaimer\r\nPicoQuant GmbH disclaims all warranties with regard to this software and associated\r\ndocumentation including all implied warranties of merchantability and fitness. \r\nIn no case shall PicoQuant GmbH be liable for any direct, indirect or consequential\r\ndamages or any material or immaterial damages whatsoever resulting from loss of data,\r\ntime or profits arising from use or performance of this software.\r\n\"\"\"\r\nimport time\r\nimport ctypes as ct\r\nfrom ctypes import byref\r\nimport sys\r\nimport struct\r\n\r\n# From hhdefin.h\r\nLIB_VERSION = \"3.0\"\r\nMAXDEVNUM = 8\r\nMODE_T2 = 2\r\nMODE_T3 = 3\r\nMAXLENCODE = 6\r\nHHMAXINPCHAN = 8\r\nTTREADMAX = 131072\r\nFLAG_OVERFLOW = 0x0001\r\nFLAG_FIFOFULL = 0x0002\r\n\r\n# Measurement parameters, these are hardcoded since this is just a demo\r\nmode = MODE_T2 # set T2 or T3 here, observe suitable Syncdivider and Range!\r\nbinning = 0 # you can change this, meaningful only in T3 mode\r\noffset = 0 # you can change this, meaningful only in T3 mode\r\ntacq = 1000 # Measurement time in millisec, you can change this\r\nsyncDivider = 1 # you can change this, observe mode! READ MANUAL!\r\nsyncCFDZeroCross = 10 # you can change this (in mV)\r\nsyncCFDLevel = 50 # you can change this (in mV)\r\nsyncChannelOffset = -5000 # you can change this (in ps, like a cable delay)\r\ninputCFDZeroCross = 10 # you can change this (in mV)\r\ninputCFDLevel = 50 # you can change this (in mV)\r\ninputChannelOffset = 0 # you can change this (in ps, like a cable delay)\r\n\r\n# Variables to store information read from DLLs\r\nbuffer = (ct.c_uint * TTREADMAX)()\r\ndev = []\r\nlibVersion = ct.create_string_buffer(b\"\", 8)\r\nhwSerial = ct.create_string_buffer(b\"\", 8)\r\nhwPartno = ct.create_string_buffer(b\"\", 8)\r\nhwVersion = ct.create_string_buffer(b\"\", 8)\r\nhwModel = ct.create_string_buffer(b\"\", 16)\r\nerrorString = ct.create_string_buffer(b\"\", 40)\r\nnumChannels = ct.c_int()\r\nresolution = ct.c_double()\r\nsyncRate = ct.c_int()\r\ncountRate = ct.c_int()\r\nflags = ct.c_int()\r\nnRecords = ct.c_int()\r\nctcstatus = ct.c_int()\r\nwarnings = ct.c_int()\r\nwarningstext = ct.create_string_buffer(b\"\", 16384)\r\n\r\ntry:\r\n    hhlib = ct.CDLL(\"hhlib64.dll\")\r\nexcept Exception, e:\r\n    eta.send(\"hhlib64.dll not found. Please copy it to the folder of ETA-Backend.exe\",\"err\")\r\n    \r\ndef closeDevices():\r\n    for i in range(0, MAXDEVNUM):\r\n        hhlib.HH_CloseDevice(ct.c_int(i))\r\n    exit(0)\r\n\r\ndef stoptttr():\r\n    retcode = hhlib.HH_StopMeas(ct.c_int(dev[0]))\r\n    if retcode < 0:\r\n        print(\"HH_StopMeas error %1d. Aborted.\" % retcode)\r\n    closeDevices()\r\n\r\ndef tryfunc(retcode, funcName, measRunning=False):\r\n    if retcode < 0:\r\n        hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\r\n        print(\"HH_%s error %d (%s). Aborted.\" % (funcName, retcode,\\\r\n              errorString.value.decode(\"utf-8\")))\r\n        if measRunning:\r\n            stoptttr()\r\n        else:\r\n            closeDevices()\r\n\r\nhhlib.HH_GetLibraryVersion(libVersion)\r\nprint(\"Library version is %s\" % libVersion.value.decode(\"utf-8\"))\r\nif libVersion.value.decode(\"utf-8\") != LIB_VERSION:\r\n    print(\"Warning: The application was built for version %s\" % LIB_VERSION)\r\n\r\noutputfile = open(\"tttrmode.out\", \"wb+\")\r\n\r\nprint(\"\\nMode             : %d\" % mode)\r\nprint(\"Binning           : %d\" % binning)\r\nprint(\"Offset            : %d\" % offset)\r\nprint(\"AcquisitionTime   : %d\" % tacq)\r\nprint(\"SyncDivider       : %d\" % syncDivider)\r\nprint(\"SyncCFDZeroCross  : %d\" % syncCFDZeroCross)\r\nprint(\"SyncCFDLevel      : %d\" % syncCFDLevel)\r\nprint(\"InputCFDZeroCross : %d\" % inputCFDZeroCross)\r\nprint(\"InputCFDLevel     : %d\" % inputCFDLevel)\r\n\r\nprint(\"\\nSearching for HydraHarp devices...\")\r\nprint(\"Devidx     Status\")\r\n\r\nfor i in range(0, MAXDEVNUM):\r\n    retcode = hhlib.HH_OpenDevice(ct.c_int(i), hwSerial)\r\n    if retcode == 0:\r\n        print(\"  %1d        S/N %s\" % (i, hwSerial.value.decode(\"utf-8\")))\r\n        dev.append(i)\r\n    else:\r\n        if retcode == -1: # HH_ERROR_DEVICE_OPEN_FAIL\r\n            print(\"  %1d        no device\" % i)\r\n        else:\r\n            hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\r\n            print(\"  %1d        %s\" % (i, errorString.value.decode(\"utf8\")))\r\n\r\n# In this demo we will use the first HydraHarp device we find, i.e. dev[0].\r\n# You can also use multiple devices in parallel.\r\n# You can also check for specific serial numbers, so that you always know \r\n# which physical device you are talking to.\r\n\r\nif len(dev) < 1:\r\n    print(\"No device available.\")\r\n    closeDevices()\r\nprint(\"Using device #%1d\" % dev[0])\r\nprint(\"\\nInitializing the device...\")\r\n\r\n# with internal clock\r\ntryfunc(hhlib.HH_Initialize(ct.c_int(dev[0]), ct.c_int(mode), ct.c_int(0)),\\\r\n        \"Initialize\")\r\n\r\n# Only for information\r\ntryfunc(hhlib.HH_GetHardwareInfo(dev[0], hwModel, hwPartno, hwVersion),\\\r\n        \"GetHardwareInfo\")\r\nprint(\"Found Model %s Part no %s Version %s\" % (hwModel.value.decode(\"utf-8\"),\\\r\n      hwPartno.value.decode(\"utf-8\"), hwVersion.value.decode(\"utf-8\")))\r\n\r\ntryfunc(hhlib.HH_GetNumOfInputChannels(ct.c_int(dev[0]), byref(numChannels)),\\\r\n        \"GetNumOfInputChannels\")\r\nprint(\"Device has %i input channels.\" % numChannels.value)\r\n\r\nprint(\"\\nCalibrating...\")\r\ntryfunc(hhlib.HH_Calibrate(ct.c_int(dev[0])), \"Calibrate\")\r\ntryfunc(hhlib.HH_SetSyncDiv(ct.c_int(dev[0]), ct.c_int(syncDivider)), \"SetSyncDiv\")\r\n\r\ntryfunc(\r\n    hhlib.HH_SetSyncCFD(ct.c_int(dev[0]), ct.c_int(syncCFDLevel),\r\n                        ct.c_int(syncCFDZeroCross)),\\\r\n    \"SetSyncCFD\"\r\n)\r\n\r\ntryfunc(hhlib.HH_SetSyncChannelOffset(ct.c_int(dev[0]), ct.c_int(syncChannelOffset)),\\\r\n        \"SetSyncChannelOffset\")\r\n\r\n# we use the same input settings for all channels, you can change this\r\nfor i in range(0, numChannels.value):\r\n    tryfunc(\r\n        hhlib.HH_SetInputCFD(ct.c_int(dev[0]), ct.c_int(i), ct.c_int(inputCFDLevel),\\\r\n                             ct.c_int(inputCFDZeroCross)),\\\r\n        \"SetInputCFD\"\r\n    )\r\n\r\n    tryfunc(\r\n        hhlib.HH_SetInputChannelOffset(ct.c_int(dev[0]), ct.c_int(i),\\\r\n                                       ct.c_int(inputChannelOffset)),\\\r\n        \"SetInputChannelOffset\"\r\n    )\r\n\r\n# Meaningful only in T3 mode\r\nif mode == MODE_T3:\r\n    tryfunc(hhlib.HH_SetBinning(ct.c_int(dev[0]), ct.c_int(binning)), \"SetBinning\")\r\n    tryfunc(hhlib.HH_SetOffset(ct.c_int(dev[0]), ct.c_int(offset)), \"SetOffset\")\r\n    tryfunc(hhlib.HH_GetResolution(ct.c_int(dev[0]), byref(resolution)), \"GetResolution\")\r\n    print(\"Resolution is %1.1lfps\" % resolution.value)\r\n\r\n# Note: after Init or SetSyncDiv you must allow >100 ms for valid  count rate readings\r\ntime.sleep(0.2)\r\n\r\ntryfunc(hhlib.HH_GetSyncRate(ct.c_int(dev[0]), byref(syncRate)), \"GetSyncRate\")\r\nprint(\"\\nSyncrate=%1d/s\" % syncRate.value)\r\n\r\nfor i in range(0, numChannels.value):\r\n    tryfunc(hhlib.HH_GetCountRate(ct.c_int(dev[0]), ct.c_int(i), byref(countRate)),\\\r\n            \"GetCountRate\")\r\n    print(\"Countrate[%1d]=%1d/s\" % (i, countRate.value))\r\n\r\nprogress = 0\r\nsys.stdout.write(\"\\nProgress:%9u\" % progress)\r\nsys.stdout.flush()\r\n\r\ntryfunc(hhlib.HH_StartMeas(ct.c_int(dev[0]), ct.c_int(tacq)), \"StartMeas\")\r\n\r\nwhile True:\r\n    tryfunc(hhlib.HH_GetFlags(ct.c_int(dev[0]), byref(flags)), \"GetFlags\")\r\n    \r\n    if flags.value & FLAG_FIFOFULL > 0:\r\n        print(\"\\nFiFo Overrun!\")\r\n        stoptttr()\r\n    \r\n    tryfunc(\r\n        hhlib.HH_ReadFiFo(ct.c_int(dev[0]), byref(buffer), TTREADMAX,\\\r\n                          byref(nRecords)),\\\r\n        \"ReadFiFo\", measRunning=True\r\n    )\r\n\r\n    if nRecords.value > 0:\r\n        # We could just iterate through our buffer with a for loop, however,\r\n        # this is slow and might cause a FIFO overrun. So instead, we shrinken\r\n        # the buffer to its appropriate length with array slicing, which gives\r\n        # us a python list. This list then needs to be converted back into\r\n        # a ctype array which can be written at once to the output file\r\n        outputfile.write((ct.c_uint*nRecords.value)(*buffer[0:nRecords.value]))\r\n        progress += nRecords.value\r\n        sys.stdout.write(\"\\rProgress:%9u\" % progress)\r\n        sys.stdout.flush()\r\n    else:\r\n        tryfunc(hhlib.HH_CTCStatus(ct.c_int(dev[0]), byref(ctcstatus)),\\\r\n                \"CTCStatus\")\r\n        if ctcstatus.value > 0: \r\n            print(\"\\nDone\")\r\n            stoptttr()\r\n    # within this loop you can also read the count rates if needed.\r\n\r\ncloseDevices()\r\noutputfile.close()\r\n","dpp_templatek71lsycj":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\neta.send(\"Installing ETA DLC... \", \"running\")\r\n\r\neta.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/HH400_HG/HH400HeaderGenerator.zip\",\"./\",\"HH400HeaderGenerator.zip\")\r\neta.send(\"ETA DLC installed.\", \"stopped\")\r\neta.send(\"Please find the LabVIEW code at \"+os.getcwd()+\"\\\\HH400HeaderGenerator\")\r\nos.startfile(os.getcwd()+\"\\\\HH400HeaderGenerator\")","var_templatek71lu4ak":null,"dpp_templatek7r3sgz1":"import pathlib\nimport logging\n\nimport numpy as np\n\nfrom bokeh.application import Application\nfrom bokeh.application.handlers.function import FunctionHandler\nimport etabackend.tk as etatk\n\nlogger = logging.getLogger('etabackend.frontend')\n\nlogger.info(\"ETA realtime is started.\")\n\nrecords_per_cut = int(float(records_per_cut)\n                      ) if records_per_cut != \"\" else None\n\nSIMULATE_GROWTH = True\nDATAFOLDER = 'analyzed data'\nLABEL = 'histogram'\n\nbinsize = int(float(binsize))\nbins = int(float(bins))\nbin_factor = int(float(binsize))\nfile = pathlib.Path(file)\n\n#------ADJUST DELAY-----\ndelay = int(float(delay))\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\neta.load_recipe()\n\n#------Evaluate Data-----\nclass HistogramResult(etatk.data.ETAResult):\n    def calculate_result(self, result):\n        hist1 = result['h3']\n        hist2 = result['h4']\n        hist0 = result[\"h4_zero\"]\n        hist1[0] += hist0[0]\n        xdata = np.arange(-hist2.size, hist1.size) * bin_factor\n        ydata = np.concatenate((hist2[::-1], hist1))\n        return xdata, ydata\n\nresult = HistogramResult(file, group=HH400_mode, records_per_cut=records_per_cut, \n                         kernel=eta, timeout=0.2, \n                         simulate_growth=SIMULATE_GROWTH)\nbp = etatk.plot.ETABokehPlot(result, result_folder=DATAFOLDER, result_label=LABEL)\n\nnot_displaying = eta.display(Application(FunctionHandler(bp.bokeh_plot_document)), 'bokeh')\nbp.run(not_displaying)\n\nlogger.info(\"ETA realtime is stopped.\")","var_templatek7uj6ou8":null,"dpp_templatek88yfdpn":"#------IMPORTS-----\n\nimport numpy as np\nimport pandas as pd\nfrom pathlib import Path\n\nimport etabackend.tk.plot as etaplt\nimport etabackend.tk.utils as etautils\n\n#------ADJUST DELAY-----\ndelay = int(float(delay))\neta.recipe.set_parameter(\"bw_delay\",str(max(0,-1*delay)))\neta.recipe.set_parameter(\"fw_delay\",str(max(0,delay)))\neta.load_recipe()\n\n#------ETA PROCESSING-----\ncut=eta.clips(Path(file))\nresult= eta.run({\"timetagger1\":cut}, group=HH400_mode)\nhist1=result[\"h3\"]\nhist2=result[\"h4\"]\nhist0=result[\"h4_zero\"]\nhist1[0]+= hist0[0]\n\nfullhist=np.concatenate((hist2[::-1],hist1))\nxdata = np.arange(-hist2.size,hist1.size)*int(float(binsize))\n\nf=Path(file)\nDATAFOLDER = 'analyzed data'\nLABEL = 'correlation'\n#------PLOTTING-----\n\ndf = pd.DataFrame(np.vstack((xdata, fullhist)).T, \n                  columns=['time bins', 'histogram events'])\ndf['log events'] = np.clip(df['histogram events'].values, 0.5, None)\n\ndef generate_doc(doc):\n    root = etaplt.plot_histogram(df, f, f.parent.joinpath(DATAFOLDER), \n                                 data_name=LABEL.capitalize(), file_label=LABEL.lower(), \n                                 info=etautils.info(globals_dict=globals(), recipe_type='correlation'))\n    doc.add_root(root)\n    return doc\n\neta.display(generate_doc, 'bokeh')\n","var_templatek8g3kag4":null,"var_templatek8g498fo":null,"var_templatek8g49hcs":null}
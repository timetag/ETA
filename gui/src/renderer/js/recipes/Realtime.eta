{"vi_templatejg59migx":"{\"nodes\":[{\"x\":152,\"y\":120,\"fixed\":true,\"text\":\"a\",\"px\":152,\"py\":120,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"1\"}],\"usercode\":\"a:\\n    emit(3,0)#90000000\"}","vi_templatejfc9koma":"{\"nodes\":[{\"x\":82,\"y\":81,\"fixed\":true,\"text\":\"a\",\"px\":82,\"py\":81,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":0,\"text\":\"0\"}],\"usercode\":\"a:\\n    emit(2,0)\"}","vi_templatejg52ksbp":"{\"nodes\":[{\"x\":374,\"y\":109,\"fixed\":true,\"text\":\"start\",\"px\":374,\"py\":109},{\"x\":101,\"y\":103,\"fixed\":true,\"text\":\"stop\",\"px\":101,\"py\":103,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"3\"},{\"source\":1,\"target\":0,\"text\":\"2\"},{\"source\":0,\"target\":0,\"text\":\"2\"},{\"source\":1,\"target\":1,\"text\":\"3\"}],\"usercode\":\"HISTOGRAM(h3,(`bins`,`binsize`))\\nINTEGER(i1,0)\\nCLOCK(c3,100,1)\\nstart:\\n    {i1+=AbsTime_ps}\\n    c3.start()\\n\\nstop:\\n    c3.stop()\\n    h3.record(c3)\\n\"}","vi_templatejfb2qshf":"{\"nodes\":[{\"x\":346,\"y\":111,\"fixed\":true,\"text\":\"start\",\"px\":346,\"py\":111},{\"x\":75,\"y\":66,\"fixed\":true,\"text\":\"stop\",\"px\":75,\"py\":66,\"initial\":true}],\"edges\":[{\"source\":0,\"target\":1,\"text\":\"2\"},{\"source\":1,\"target\":0,\"text\":\"3\"},{\"source\":0,\"target\":0,\"text\":\"3\"},{\"source\":1,\"target\":1,\"text\":\"2\"}],\"usercode\":\"HISTOGRAM(h4,(`bins`,`binsize`))\\nCLOCK(c4,100,1)\\nstart:\\n    c4.start()\\nstop:\\n    c4.stop()\\n    h4.record(c4)\"}","dpp_template_code":"#------IMPORTS-----\r\nfrom os import path\r\nimport pathlib\r\nfrom enum import Enum\r\n\r\nimport numpy as np\r\nimport matplotlib.pyplot as plt\r\nimport matplotlib.animation as animation\r\nimport matplotlib.widgets\r\nfrom matplotlib.widgets import Button\r\n\r\neta.send(\"ETA is running in realtime...\", \"running\")\r\n\r\nrecords_per_cut = int(float(records_per_cut)) if records_per_cut != \"\" else None\r\n\r\nSIMULATE_GROWTH = False\r\nDATAFOLDER = 'analyzed data'\r\nLABEL = 'histogram'\r\n\r\nbinsize = int(float(binsize))\r\nbins = int(float(bins))\r\nbin_factor = int(float(binsize))\r\nfile = pathlib.Path(file)\r\n\r\nctx1=None\r\nfig, ax = plt.subplots()\r\nax.set_ylabel('Histogram events')\r\nax.set_xlabel('Time delay (ps)')\r\nax.set_title(expname)\r\n\r\n\r\nclass DataPlot(object):\r\n    def __init__(self, fig, ax, file, bin_factor, \r\n                 records_per_cut=None, interval=100, \r\n                 numpy=None, widgets=None):\r\n        \"\"\" Calculates the next cut and writes it to the plot\r\n            ax: Axis to draw on\r\n            file: str or Path of file currently investigated\r\n            bin_factor: The multiplication factor for each bin.\r\n            interval: The interval of the simulation\r\n            timeout: How long to wait for enough data until frame is skipped (milliseconds)\r\n        \"\"\"\r\n        global SIMULATE_GROWTH\r\n        \r\n        self.file = file\r\n        self.bin_factor = bin_factor\r\n        self.records_per_cut = records_per_cut\r\n        \r\n        self.fig = fig\r\n        self.ax = ax\r\n        self.fig.subplots_adjust(bottom=0.22)\r\n        \r\n        self.line, = self.ax.plot([], [], 'r-')\r\n        self.interval = interval\r\n        self.numpy = numpy\r\n        self.widgets = widgets\r\n        \r\n        self.set_accumulation_mode()\r\n\r\n        # Setup Widgets\r\n        axsavedat = self.fig.add_axes([0.59, 0.05, 0.1, 0.075])\r\n        axmode = self.fig.add_axes([0.7, 0.05, 0.1, 0.075])\r\n        axlinlog = self.fig.add_axes([0.81, 0.05, 0.1, 0.075])\r\n        self.bsavedat = widgets.Button(axsavedat, 'Save')\r\n        self.blinlog = widgets.Button(axlinlog, 'Lin/Log')\r\n        self.bmode = widgets.Button(axmode, 'Mode')\r\n        self.bsavedat.on_clicked(self.save_dat)\r\n        self.blinlog.on_clicked(self.toggle_scale)\r\n        self.bmode.on_clicked(self.toggle_mode)\r\n        \r\n        # First cut to detect file properties and rate estimation\r\n        self.cut = eta.incremental_cut(self.file, cut=None,\r\n                                       rec_per_cut=1,\r\n                                       verbose=False)\r\n        \r\n        if self.records_per_cut is None:\r\n            self.estimate_growth()\r\n\r\n        self.waiting = False\r\n        self.context = None\r\n        \r\n        if SIMULATE_GROWTH is False:\r\n            file_size = self.file.stat().st_size\r\n            file_size = file_size - self.cut[0][0]\r\n            existing_records = file_size//self.cut[0][5]\r\n        else:\r\n            existing_records = self.records_per_cut\r\n\r\n        self.cut = eta.incremental_cut(self.file, cut=None, \r\n                                       rec_per_cut=existing_records, verbose=False) # Start always from begining of file\r\n        \r\n        if not eta.wait_for_data(self.cut, timeout=0.01):\r\n            eta.send('Something went wrong, there should be no waiting here.')\r\n            \r\n        result, self.context = eta.run(self.cut, group='main',\r\n                                       ctxs=None, sum_results=True, \r\n                                       iterate_ctxs=True, verbose=False)\r\n        self.hist1 = result['h3']\r\n        self.hist2 = result['h4']\r\n        self.ydata = self.numpy.concatenate((self.numpy.flip(self.hist2, 0), self.hist1), axis=0)\r\n        self.max_value = self.numpy.amax(self.ydata) \r\n        self.y_max = self.max_value*1.5\r\n\r\n        self.xdata = self.numpy.arange(-result['h4'].size,result['h3'].size)*self.bin_factor\r\n\r\n    def estimate_growth(self):\r\n        \"\"\" Estimates the grow rate per second, will sleep for 1000ms.\r\n        The event loop continues running.\r\n        \"\"\"\r\n        eta.send('Estimating File growth.')\r\n        file_size_old = self.file.stat().st_size\r\n        plt.pause(1)\r\n        file_size_new = self.file.stat().st_size\r\n        eta.send('Done.')\r\n        \r\n        self.growth_rate = (file_size_new - file_size_old)/self.cut[0][5] #Bytes per record\r\n        self.records_per_cut = int(self.growth_rate * self.interval)\r\n    \r\n    def init(self):\r\n        \"\"\" Initializes the figure\r\n        \"\"\"\r\n        self.ax.set_xlim(-self.hist2.size*self.bin_factor, self.hist1.size*self.bin_factor)\r\n        self.line.set_xdata(self.xdata)\r\n        \r\n        self.y_max=self.numpy.amax(self.ydata)*1.5\r\n        self.ax.set_ylim(0.01, self.y_max)\r\n        self.line.set_ydata(self.ydata)\r\n        \r\n        return self.line,\r\n    \r\n\r\n    def __call__(self, i):\r\n        # This way the plot can continuously run and we just keep\r\n        # watching new realizations of the process\r\n        if i == 0:\r\n            return self.init()\r\n        \r\n        if self.waiting == False:\r\n            self.cut = eta.incremental_cut(self.file, cut=self.cut, \r\n                                            rec_per_cut=self.records_per_cut, verbose=False)\r\n\r\n        if not eta.wait_for_data(self.cut, timeout=0.01):\r\n            self.waiting = True\r\n            # No new data available, we do not modify the plot\r\n            return self.line,\r\n        else:\r\n            self.waiting = False\r\n            context = self.context if self.mode == 'accumulation' else None\r\n            \r\n            result, self.context = eta.run(self.cut, group='main',\r\n                                           ctxs=context, sum_results=True, \r\n                                           iterate_ctxs=True, verbose=False)\r\n                                           \r\n            self.hist1 = result['h3']\r\n            self.hist2 = result['h4']\r\n            self.ydata = self.numpy.concatenate((self.numpy.flip(self.hist2, 0), self.hist1), axis=0)\r\n        \r\n        max_value = self.numpy.amax(self.ydata)\r\n        if max_value >= self.y_max*0.9 or max_value < self.max_value*0.9:\r\n            self.y_max = max_value*1.5\r\n            self.max_value = max_value\r\n            self.ax.set_ylim(0.01, self.y_max)\r\n            self.fig.canvas.draw_idle()\r\n\r\n        self.line.set_ydata(self.ydata)\r\n        return self.line,\r\n    \r\n    def toggle_scale(self, event):\r\n        if self.ax.get_yscale() == 'log':\r\n            self.set_linear()\r\n        elif self.ax.get_yscale() == 'linear':\r\n            self.set_log()\r\n        self.fig.canvas.draw_idle()    \r\n\r\n    def set_log(self):\r\n        print(self.numpy.min(self.ydata))\r\n        \r\n        self.ax.set_yscale('log', nonposy='clip')\r\n\r\n    def set_linear(self):\r\n        self.ax.set_yscale('linear')\r\n        \r\n    def set_accumulation_mode(self):\r\n        self.mode = 'accumulation'\r\n        \r\n    def set_alignment_mode(self):\r\n        self.mode = 'align'\r\n\r\n    def toggle_mode(self, event):\r\n        if self.mode == 'align':\r\n            self.set_accumulation_mode()\r\n        elif self.mode == 'accumulation':\r\n            self.set_alignment_mode()\r\n    \r\n    def save_dat(self, event):\r\n        global DATAFOLDER, LABEL\r\n        self.file.parent.joinpath(DATAFOLDER).mkdir(parents=True, exist_ok=True) # Create analyzed folder\r\n        \r\n        file_index = 0\r\n        while self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\").exists(): #create unique index for file\r\n            file_index += 1\r\n            \r\n        self.numpy.savetxt(self.file.parent.joinpath(DATAFOLDER, f\"{self.file.stem}_{LABEL}_{file_index:0=3d}.txt\"), \r\n                           self.numpy.transpose([self.xdata, self.ydata]))\r\n\r\ndp = DataPlot(fig, ax, file, bin_factor, records_per_cut, interval=100, \r\n              numpy=np, widgets=matplotlib.widgets)\r\n\r\nani = animation.FuncAnimation(fig, dp, init_func=dp.init, interval=100, repeat=False,\r\n                              cache_frame_data=False, blit=True)\r\n\r\nplt.show()\r\n\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")\r\n","eta_index_table":"[{\"id\":\"var_templatejgmgopco\",\"name\":\"file\",\"group\":\"main\",\"info\":\"\",\"config\":\"C:/YourFolder/YourFile.timeres\"},{\"id\":\"var_templatejkil9dn6\",\"name\":\"binsize\",\"group\":\"main\",\"info\":\"\",\"config\":\"16\"},{\"id\":\"var_templatejkil7pz1\",\"name\":\"records_per_cut\",\"group\":\"main\",\"info\":\"\",\"config\":\"2e5\"},{\"id\":\"var_templatejkil6yh0\",\"name\":\"expname\",\"group\":\"main\",\"info\":\"\",\"config\":\"Realtime\"},{\"id\":\"var_templatejkil8r7x\",\"name\":\"bins\",\"group\":\"main\",\"info\":\"\",\"config\":\"1e4\"},{\"id\":\"dpp_template_code\",\"name\":\"realtime\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvphfp\",\"name\":\"qutag_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvvpsn\",\"name\":\"swabianinstrument_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejouvx190\",\"name\":\"hydraharp_start_recording\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"dpp_templatejvtn1isu\",\"name\":\"hydraharp400_HeaderGenerator_download\",\"group\":\"main\",\"info\":\"\",\"config\":\"\"},{\"id\":\"ri_templatejezi0bbr\",\"name\":\"TimeTagger\",\"group\":\"main\",\"info\":\"游닋 [0, 1]\",\"config\":\"[2,0]\"},{\"id\":\"vi_templatejfc9koma\",\"name\":\"DL0-2\",\"group\":\"main\",\"info\":\"游닌 [0], 游닋 [2] \",\"config\":\"\"},{\"id\":\"vi_templatejg59migx\",\"name\":\"DL1-3\",\"group\":\"main\",\"info\":\"游닌 [1], 游닋 [3] \",\"config\":\"\"},{\"id\":\"vi_templatejg52ksbp\",\"name\":\"Correlationbwd\",\"group\":\"main\",\"info\":\"游닌 [3, 2], 游닋 [] \",\"config\":\"\"},{\"id\":\"vi_templatejfb2qshf\",\"name\":\"Correlationfwd\",\"group\":\"main\",\"info\":\"游닌 [2, 3], 游닋 [] \",\"config\":\"\"}]","var_templatejkil6yh0":null,"var_templatejkil7pz1":null,"var_templatejkil8r7x":null,"var_templatejkil9dn6":null,"dpp_templatejouvphfp":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\nif not os.path.isfile(\"tdcbase.dll\"):\r\n    eta.send(\"Installing ETA DLC... \", \"running\")\r\n    import webinstall\r\n    webinstall.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/qutaglib/quTAGlibV1.4.1.zip\",\"./\",\"quTAGlibV141.zip\")\r\n    eta.send(\"ETA DLC installed. \", \"stopped\")\r\ntry:\r\n    qutag = cdll.LoadLibrary(\"tdcbase.dll\")\r\nexcept Exception:\r\n    eta.send(\"You need to copy tdcbase.dll along with other dlls to the same folder of ETA-Backend.exe\",\"err\")\r\n    #You can find those DLLs from the 64bit library at\r\n    #https://www.qutools.com/\r\n    #You might also need a newer version of quTAG driver that allows configuration of the filters\r\nqutag.TDC_getVersion.restype=c_double\r\nprint(qutag.TDC_getVersion())\r\nrc = qutag.TDC_init( -1 )\r\nprint( \"TDC_init\", rc )\r\nrc = qutag.TDC_enableChannels( 0xff ) # Use all channels \r\nprint( \"TDC_enableChannels\", rc )\r\n\r\n\r\nrc = qutag.TDC_configureFilter(5,3,0b00110) # (channel to filter, enumerator for filtertype (3=sync),0bchannelmask)\r\nprint( \"TDC_configureFilter\", rc )\r\n\r\nfilename= str(file).encode(\"utf-8\")\r\neta.send(\"Timetags will be written to {}\".format(filename))\r\neta.send(\"ETA starting reading the timetags from device...\", \"running\")\r\nrc = qutag.TDC_writeTimestamps(create_string_buffer(filename),1)#start acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\ntime.sleep(10)\r\nrc = qutag.TDC_writeTimestamps(POINTER(c_int)(),1)#stop acquisition\r\nprint( \"TDC_writeTimestamps\", rc )\r\neta.send(\"ETA realtime is stopped.\", \"stopped\")","dpp_templatejouvvpsn":"import sys\r\ntry:\r\n    import TimeTagger\r\nexcept:\r\n    print(\"Time Tagger lib is not in the search path.\")\r\n    pyversion = sys.version_info\r\n    from winreg import ConnectRegistry, OpenKey, HKEY_LOCAL_MACHINE, QueryValueEx\r\n    registry_path = \"SOFTWARE\\\\Python\\\\PythonCore\\\\\" + \\\r\n        str(pyversion.major) + \".\" + str(pyversion.minor) + \"\\\\PythonPath\\\\Time Tagger\"\r\n    reg = ConnectRegistry(None, HKEY_LOCAL_MACHINE)\r\n    key = OpenKey(reg, registry_path)\r\n    module_path = QueryValueEx(key, '')[0]\r\n    print(\"adding \" + module_path)\r\n    sys.path.append(module_path)\r\nimport TimeTagger\r\n\r\nfrom time import sleep\r\n\r\ntagger = TimeTagger.createTimeTagger()\r\ntagger.reset();\r\n#disabling the test signals\r\ntagger.setTestSignal(0, False)\r\ntagger.setTestSignal(1, False)\r\ntagger.setTestSignal(5, False)\r\n#setTriggerLevel to chn0 ,chn1, chn5\r\ntagger.setTriggerLevel(0, 0.1)\r\ntagger.setTriggerLevel(1, 0.1)\r\ntagger.setTriggerLevel(5, 0.1)\r\ntagger.sync()\r\ncountrate =  TimeTagger.Countrate( tagger, channels=[0,1,5] )\r\nsleep(1)\r\neta.send('countrate:')\r\neta.send(countrate.getData())\r\n\r\neta.send('starting time-tagging',\"running\")\r\ndump =  TimeTagger.Dump(tagger,'swebian.bin',100000,[0,1,5])\r\nsleep(10)\r\neta.send('stopping time-tagging', \"stopped\")","dpp_templatejouvx190":"#TODO(20181124) This script is not yet tested on a real device.\n\n# Demo for access to HydraHarp 400 Hardware via HHLIB.DLL v 3.0.\n# The program performs a measurement based on hard coded settings.\n# The resulting data is stored in a binary output file.\n#\n# Keno Goertz, PicoQuant GmbH, February 2018\n\"\"\"\nDisclaimer\nPicoQuant GmbH disclaims all warranties with regard to this software and associated\ndocumentation including all implied warranties of merchantability and fitness. \nIn no case shall PicoQuant GmbH be liable for any direct, indirect or consequential\ndamages or any material or immaterial damages whatsoever resulting from loss of data,\ntime or profits arising from use or performance of this software.\n\"\"\"\nimport time\nimport ctypes as ct\nfrom ctypes import byref\nimport sys\nimport struct\n\n# From hhdefin.h\nLIB_VERSION = \"3.0\"\nMAXDEVNUM = 8\nMODE_T2 = 2\nMODE_T3 = 3\nMAXLENCODE = 6\nHHMAXINPCHAN = 8\nTTREADMAX = 131072\nFLAG_OVERFLOW = 0x0001\nFLAG_FIFOFULL = 0x0002\n\n# Measurement parameters, these are hardcoded since this is just a demo\nmode = MODE_T2 # set T2 or T3 here, observe suitable Syncdivider and Range!\nbinning = 0 # you can change this, meaningful only in T3 mode\noffset = 0 # you can change this, meaningful only in T3 mode\ntacq = 1000 # Measurement time in millisec, you can change this\nsyncDivider = 1 # you can change this, observe mode! READ MANUAL!\nsyncCFDZeroCross = 10 # you can change this (in mV)\nsyncCFDLevel = 50 # you can change this (in mV)\nsyncChannelOffset = -5000 # you can change this (in ps, like a cable delay)\ninputCFDZeroCross = 10 # you can change this (in mV)\ninputCFDLevel = 50 # you can change this (in mV)\ninputChannelOffset = 0 # you can change this (in ps, like a cable delay)\n\n# Variables to store information read from DLLs\nbuffer = (ct.c_uint * TTREADMAX)()\ndev = []\nlibVersion = ct.create_string_buffer(b\"\", 8)\nhwSerial = ct.create_string_buffer(b\"\", 8)\nhwPartno = ct.create_string_buffer(b\"\", 8)\nhwVersion = ct.create_string_buffer(b\"\", 8)\nhwModel = ct.create_string_buffer(b\"\", 16)\nerrorString = ct.create_string_buffer(b\"\", 40)\nnumChannels = ct.c_int()\nresolution = ct.c_double()\nsyncRate = ct.c_int()\ncountRate = ct.c_int()\nflags = ct.c_int()\nnRecords = ct.c_int()\nctcstatus = ct.c_int()\nwarnings = ct.c_int()\nwarningstext = ct.create_string_buffer(b\"\", 16384)\n\ntry:\n    hhlib = ct.CDLL(\"hhlib64.dll\")\nexcept Exception, e:\n    eta.send(\"hhlib64.dll not found. Please copy it to the folder of ETA-Backend.exe\",\"err\")\n    \ndef closeDevices():\n    for i in range(0, MAXDEVNUM):\n        hhlib.HH_CloseDevice(ct.c_int(i))\n    exit(0)\n\ndef stoptttr():\n    retcode = hhlib.HH_StopMeas(ct.c_int(dev[0]))\n    if retcode < 0:\n        print(\"HH_StopMeas error %1d. Aborted.\" % retcode)\n    closeDevices()\n\ndef tryfunc(retcode, funcName, measRunning=False):\n    if retcode < 0:\n        hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\n        print(\"HH_%s error %d (%s). Aborted.\" % (funcName, retcode,\\\n              errorString.value.decode(\"utf-8\")))\n        if measRunning:\n            stoptttr()\n        else:\n            closeDevices()\n\nhhlib.HH_GetLibraryVersion(libVersion)\nprint(\"Library version is %s\" % libVersion.value.decode(\"utf-8\"))\nif libVersion.value.decode(\"utf-8\") != LIB_VERSION:\n    print(\"Warning: The application was built for version %s\" % LIB_VERSION)\n\noutputfile = open(\"tttrmode.out\", \"wb+\")\n\nprint(\"\\nMode             : %d\" % mode)\nprint(\"Binning           : %d\" % binning)\nprint(\"Offset            : %d\" % offset)\nprint(\"AcquisitionTime   : %d\" % tacq)\nprint(\"SyncDivider       : %d\" % syncDivider)\nprint(\"SyncCFDZeroCross  : %d\" % syncCFDZeroCross)\nprint(\"SyncCFDLevel      : %d\" % syncCFDLevel)\nprint(\"InputCFDZeroCross : %d\" % inputCFDZeroCross)\nprint(\"InputCFDLevel     : %d\" % inputCFDLevel)\n\nprint(\"\\nSearching for HydraHarp devices...\")\nprint(\"Devidx     Status\")\n\nfor i in range(0, MAXDEVNUM):\n    retcode = hhlib.HH_OpenDevice(ct.c_int(i), hwSerial)\n    if retcode == 0:\n        print(\"  %1d        S/N %s\" % (i, hwSerial.value.decode(\"utf-8\")))\n        dev.append(i)\n    else:\n        if retcode == -1: # HH_ERROR_DEVICE_OPEN_FAIL\n            print(\"  %1d        no device\" % i)\n        else:\n            hhlib.HH_GetErrorString(errorString, ct.c_int(retcode))\n            print(\"  %1d        %s\" % (i, errorString.value.decode(\"utf8\")))\n\n# In this demo we will use the first HydraHarp device we find, i.e. dev[0].\n# You can also use multiple devices in parallel.\n# You can also check for specific serial numbers, so that you always know \n# which physical device you are talking to.\n\nif len(dev) < 1:\n    print(\"No device available.\")\n    closeDevices()\nprint(\"Using device #%1d\" % dev[0])\nprint(\"\\nInitializing the device...\")\n\n# with internal clock\ntryfunc(hhlib.HH_Initialize(ct.c_int(dev[0]), ct.c_int(mode), ct.c_int(0)),\\\n        \"Initialize\")\n\n# Only for information\ntryfunc(hhlib.HH_GetHardwareInfo(dev[0], hwModel, hwPartno, hwVersion),\\\n        \"GetHardwareInfo\")\nprint(\"Found Model %s Part no %s Version %s\" % (hwModel.value.decode(\"utf-8\"),\\\n      hwPartno.value.decode(\"utf-8\"), hwVersion.value.decode(\"utf-8\")))\n\ntryfunc(hhlib.HH_GetNumOfInputChannels(ct.c_int(dev[0]), byref(numChannels)),\\\n        \"GetNumOfInputChannels\")\nprint(\"Device has %i input channels.\" % numChannels.value)\n\nprint(\"\\nCalibrating...\")\ntryfunc(hhlib.HH_Calibrate(ct.c_int(dev[0])), \"Calibrate\")\ntryfunc(hhlib.HH_SetSyncDiv(ct.c_int(dev[0]), ct.c_int(syncDivider)), \"SetSyncDiv\")\n\ntryfunc(\n    hhlib.HH_SetSyncCFD(ct.c_int(dev[0]), ct.c_int(syncCFDLevel),\n                        ct.c_int(syncCFDZeroCross)),\\\n    \"SetSyncCFD\"\n)\n\ntryfunc(hhlib.HH_SetSyncChannelOffset(ct.c_int(dev[0]), ct.c_int(syncChannelOffset)),\\\n        \"SetSyncChannelOffset\")\n\n# we use the same input settings for all channels, you can change this\nfor i in range(0, numChannels.value):\n    tryfunc(\n        hhlib.HH_SetInputCFD(ct.c_int(dev[0]), ct.c_int(i), ct.c_int(inputCFDLevel),\\\n                             ct.c_int(inputCFDZeroCross)),\\\n        \"SetInputCFD\"\n    )\n\n    tryfunc(\n        hhlib.HH_SetInputChannelOffset(ct.c_int(dev[0]), ct.c_int(i),\\\n                                       ct.c_int(inputChannelOffset)),\\\n        \"SetInputChannelOffset\"\n    )\n\n# Meaningful only in T3 mode\nif mode == MODE_T3:\n    tryfunc(hhlib.HH_SetBinning(ct.c_int(dev[0]), ct.c_int(binning)), \"SetBinning\")\n    tryfunc(hhlib.HH_SetOffset(ct.c_int(dev[0]), ct.c_int(offset)), \"SetOffset\")\n    tryfunc(hhlib.HH_GetResolution(ct.c_int(dev[0]), byref(resolution)), \"GetResolution\")\n    print(\"Resolution is %1.1lfps\" % resolution.value)\n\n# Note: after Init or SetSyncDiv you must allow >100 ms for valid  count rate readings\ntime.sleep(0.2)\n\ntryfunc(hhlib.HH_GetSyncRate(ct.c_int(dev[0]), byref(syncRate)), \"GetSyncRate\")\nprint(\"\\nSyncrate=%1d/s\" % syncRate.value)\n\nfor i in range(0, numChannels.value):\n    tryfunc(hhlib.HH_GetCountRate(ct.c_int(dev[0]), ct.c_int(i), byref(countRate)),\\\n            \"GetCountRate\")\n    print(\"Countrate[%1d]=%1d/s\" % (i, countRate.value))\n\nprogress = 0\nsys.stdout.write(\"\\nProgress:%9u\" % progress)\nsys.stdout.flush()\n\ntryfunc(hhlib.HH_StartMeas(ct.c_int(dev[0]), ct.c_int(tacq)), \"StartMeas\")\n\nwhile True:\n    tryfunc(hhlib.HH_GetFlags(ct.c_int(dev[0]), byref(flags)), \"GetFlags\")\n    \n    if flags.value & FLAG_FIFOFULL > 0:\n        print(\"\\nFiFo Overrun!\")\n        stoptttr()\n    \n    tryfunc(\n        hhlib.HH_ReadFiFo(ct.c_int(dev[0]), byref(buffer), TTREADMAX,\\\n                          byref(nRecords)),\\\n        \"ReadFiFo\", measRunning=True\n    )\n\n    if nRecords.value > 0:\n        # We could just iterate through our buffer with a for loop, however,\n        # this is slow and might cause a FIFO overrun. So instead, we shrinken\n        # the buffer to its appropriate length with array slicing, which gives\n        # us a python list. This list then needs to be converted back into\n        # a ctype array which can be written at once to the output file\n        outputfile.write((ct.c_uint*nRecords.value)(*buffer[0:nRecords.value]))\n        progress += nRecords.value\n        sys.stdout.write(\"\\rProgress:%9u\" % progress)\n        sys.stdout.flush()\n    else:\n        tryfunc(hhlib.HH_CTCStatus(ct.c_int(dev[0]), byref(ctcstatus)),\\\n                \"CTCStatus\")\n        if ctcstatus.value > 0: \n            print(\"\\nDone\")\n            stoptttr()\n    # within this loop you can also read the count rates if needed.\n\ncloseDevices()\noutputfile.close()\n","dpp_templatejvtn1isu":"#This Script Panel will start the time tagging on a quTAG device\r\n#TODO:20181124 This script is not yet tested \r\nfrom ctypes import *\r\nimport time,sys,os\r\neta.send(\"Installing ETA DLC... \", \"running\")\r\nimport webinstall\r\nwebinstall.web_install(\"https://github.com/timetag/timetag.github.io/releases/download/HH400_HG/HH400HeaderGenerator.zip\",\"./\",\"HH400HeaderGenerator.zip\")\r\neta.send(\"ETA DLC installed.\", \"stopped\")\r\neta.send(\"Please find the LabVIEW code at \"+os.getcwd()+\"\\\\HH400HeaderGenerator\")\r\nos.startfile(os.getcwd()+\"\\\\HH400HeaderGenerator\")"}